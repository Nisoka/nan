* 1.2
  实际上很酷的事 使用和调整机器学习算法 只是应用中很小的一部分工作.
  1) 读取和清洗数据
  2) 探索和理解数据
  3) 分析将数据变为什么形式,更好的提供给算法处理
  4) 选择正确的模型和算法
  5) 正确的评估性能
  探索和理解数据的时候, 统计学和基础数学知识, 你会发现他们进行处理数据是那么的有意思.
  解读数据 就是应用旅程的开始, 例如面对无效值、缺失值时, 处理方法更像是技艺而非一门科学.这部分处理的好,你的数据就能够更好地适应学习算法.
  特征工程 通常不会直接将原始数据输入算法, 而是在训练模型前, 对数据进行提炼, 很多时候提炼后的数据能够让算法的效果提高很多很多. 
  这部分工作叫做特征工程. 将原始数据 提炼 成更有效的特征数据.
  选择正确的算法 并不是简单的尝试下工具箱中的几个算法, 更需要深思熟虑, 权衡性能和功能的不同需求. 是否某个算法效率更高而不会损失质量, 未知数据是否分布随数据正常, 是否需要损失部分质量而选择更有效率算法.等等.
  性能评估 数据决定了任务的成败, 性能评估绝对不能使用相同数据, 性能评估的方法各有不同.
  本书更着重于非算法部分内容, 这能够让你真正的入门。有一个正常的应用视野.


* 1.3 

* 1.4
** 1.4.4 numpy 
   1) numpy ndarray
      a = np.array( [0, 1, 2, 3, 4, 5])
      a.ndim  1
      a.shape (6,)
   2) b = a.reshape( (3, 2) )
   3) b[1][0] = 77
      a
      array( [0, 1, 77, 3, 4, 5])
      b 只是a的一个视图, 数据两者共享.
   4) c = a.reshape( (3, 2) ).copy()
      np.array.copy() 会将ndarray真实复制
   5) a**2
      array([0, 1, 4, 9, 16, 25])
      对ndarray的算术操作 是作用到每个元素的.

   a = np.array([0, 1, 77, 3, 4, 5])
   1) 索引 numpy 的很大一部分威力来自于它的访问方式千变万化.
      维度索引:
      a[][]  
      
      坐标索引 (list 不可进行坐标索引):
      a[,]   

      数组索引:
      a[np.array([2, 3, 4])) 数组做索引

      条件索引:
      a[a>4] 
      a>4得到一个bool型数组,然后使用该数组索引a 直接就得到了条件索引方法.
      异常值修剪:
      a[a>4] = 4
      通过使用条件索引 索引a 然后通过算术赋值 直接进行了数据处理easy。
      可以通过clip函数进行异常值修剪
      a.clip(min, max) 
      eg a.clip(0, 4)  === ([0, 1, 4, 3, 4, 4])

   2) 处理不存在的值
      从文本中读取数据时, 经常numpy立刻就需要对数据进行处理,因为可能会有一些不合法值 -- numpy.NAN 这就表示它不是一个真是数值.
      c = np.array([1, 2, np.NAN, 3, 4])
      c
      array([1, 2, nan, 3, 4])
      np.isnan(c)
      array([false, false, true, false, false], dtype=bool)
      又是一个bool型的数组（或者叫条件数组）,可以用来条件索引数组
      c[~np.isnana(c)]
      array([1, 2, 3, 4])
      np.mean(c[~np.isnan(c)])
      2.5

   3) 运行时行为比较
      numpy ndarray 和 python list两种数组类型的数值处理比较.
      ndarray 访问数组单个元素 速度比list要慢不少3倍以上
      但是当使用numpy 提供的算法时, 速度能够提升10倍以上.
      所以一定要考虑 尽可能的将ndarray的数据处理 从循环处理变为扩展函数处理不然速度还不如list.
      list 可以使用任意类型,并且同一个list中也可以使用不同类型
      numpy 则不会那么灵活(也没有必要numpy主要进行数值运算), numpy会自动使用同一种类型存储数据,并且不允许一个ndarray中有两个类型.


* 1.5 数值预测

** 1.5.1 读取数据

** 1.5.2 预处理数据

** 1.5.3 选择正确的模型和算法
   
   1) 找到有噪数据 背后的真正模型.
      模型 对复杂现实世界的理论近似. 总会和现实世界有些误差。
      这个误差 能够指引我们在无数选择中选择正确的模型.
      找到最小的误差 就是我们想要的模型
      一般使用平方误差 作为 误差衡量一个模型.
   2) 高级话题
      提升模型复杂度:
      提升模型复杂度, 模型越复杂 模型对数据的逼近越好, 平方误差也越小.
      过拟合:
      然后模型越复杂 模型对数据的捕捉能力也越强, 更可能捕捉到噪音.造成过拟合.
      + 选择一个拟合的模型
	1阶模型太简单 10 100阶又过拟合 貌似2 3 阶还可以 但是在边界数据上效果太离谱.
      + 换成另外一类模型算法.
	
      + 重新审视数据, 理解数据
	数据有拐点, 可以尝试分隔数据 训练两个模型分别应用.(boost的基本思想)
   3) 训练与测试      模型评估
      需要一些数据来测试我们的模型.
      测试的数据绝对不能参与训练, 训练过的数据实际上是模型训练时进行记忆了, 必须使用为见到的数据进行.

  
* 1.6 end
  1 理解和提炼数据更重要
  2 实验方法的重要性, 实验方法合理 可以少走弯路.
  3 使用算法只是很小的一部分工作.
